{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Estrutura Projeto de Dados","text":"<p>Bem-vindo \u00e0 documenta\u00e7\u00e3o do pipeline ETL.</p>"},{"location":"#workflow","title":"Workflow","text":"<pre><code>flowchart LR\n  subgraph ETL[Pipeline]\n    A(M\u00faltiplos Arquivos Excel) --&gt; B[Extract: extract_from_excel]\n    B[Extract: extract_from_excel] --&gt; |Gera uma lista de DataFrames| C[Transformation: consolidate_dataframes]\n    C[Transformation: consolidate_dataframes] --&gt; |Gera um DataFrame Consolidado| D[Load: Converte para Excel]\n    D[Load: Converte para Excel] --&gt; |Salva o consolidado em Excel| E[Pasta Output: Um arquivo \u00danico Excel]\n  end</code></pre>"},{"location":"about/","title":"Sobre","text":"<p># Sobre Este projeto demonstra uma estrutura de ETL simples usando Python.</p>"},{"location":"pipeline/extract/","title":"Extra\u00e7\u00e3o de Dados","text":"<p>A fun\u00e7\u00e3o <code>extract_from_excel</code> \u00e9 respons\u00e1vel por ler m\u00faltiplos arquivos Excel e retorn\u00e1-los como DataFrames.</p>"},{"location":"pipeline/extract/#funcao-de-extracao-de-dados","title":"Fun\u00e7\u00e3o de Extra\u00e7\u00e3o de Dados","text":"<p>L\u00ea todos os arquivos Excel (.xlsx) em um diret\u00f3rio e retorna uma lista de DataFrames.</p> <p>Esta fun\u00e7\u00e3o utiliza o m\u00f3dulo <code>glob</code> para encontrar todos os arquivos com extens\u00e3o <code>.xlsx</code> no diret\u00f3rio especificado. Em seguida, cada arquivo \u00e9 lido usando o <code>pandas.read_excel</code>  e armazenado em uma lista de DataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>O caminho do diret\u00f3rio contendo os arquivos Excel.</p> required <p>Returns:</p> Type Description <code>List[DataFrame]</code> <p>List[pd.DataFrame]: Uma lista de DataFrames, onde cada DataFrame representa </p> <code>List[DataFrame]</code> <p>o conte\u00fado de um arquivo Excel encontrado no diret\u00f3rio.</p> Example <p>from app.pipeline.extract import extract_from_excel data_frames = extract_from_excel(\"data/input\") len(data_frames) 3  # Se houver tr\u00eas arquivos Excel no diret\u00f3rio</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Se o diret\u00f3rio especificado n\u00e3o existir.</p> <code>ValueError</code> <p>Se n\u00e3o houver arquivos Excel no diret\u00f3rio.</p> Source code in <code>app\\pipeline\\extract.py</code> <pre><code>def extract_from_excel(path: str) -&gt; List[pd.DataFrame]:\n    \"\"\"\n    L\u00ea todos os arquivos Excel (.xlsx) em um diret\u00f3rio e retorna uma lista de DataFrames.\n\n    Esta fun\u00e7\u00e3o utiliza o m\u00f3dulo `glob` para encontrar todos os arquivos com extens\u00e3o `.xlsx`\n    no diret\u00f3rio especificado. Em seguida, cada arquivo \u00e9 lido usando o `pandas.read_excel` \n    e armazenado em uma lista de DataFrames.\n\n    Args:\n        path (str): O caminho do diret\u00f3rio contendo os arquivos Excel.\n\n    Returns:\n        List[pd.DataFrame]: Uma lista de DataFrames, onde cada DataFrame representa \n        o conte\u00fado de um arquivo Excel encontrado no diret\u00f3rio.\n\n    Example:\n        &gt;&gt;&gt; from app.pipeline.extract import extract_from_excel\n        &gt;&gt;&gt; data_frames = extract_from_excel(\"data/input\")\n        &gt;&gt;&gt; len(data_frames)\n        3  # Se houver tr\u00eas arquivos Excel no diret\u00f3rio\n\n    Raises:\n        FileNotFoundError: Se o diret\u00f3rio especificado n\u00e3o existir.\n        ValueError: Se n\u00e3o houver arquivos Excel no diret\u00f3rio.\n\n    \"\"\"\n    all_files = glob.glob(os.path.join(path, \"*.xlsx\"))\n\n    data_frame_list = []\n    for file in all_files:\n        data_frame_list.append(pd.read_excel(file))\n\n    return data_frame_list\n</code></pre>"},{"location":"pipeline/load/","title":"Carregamento de Dados","text":"<p>A fun\u00e7\u00e3o <code>load_excel</code> \u00e9 respons\u00e1vel por salvar um DataFrame consolidado em um arquivo Excel, garantindo que o diret\u00f3rio de sa\u00edda exista.</p>"},{"location":"pipeline/load/#funcao-de-carregamento-de-dados","title":"Fun\u00e7\u00e3o de Carregamento de Dados","text":""},{"location":"pipeline/load/#descricao","title":"Descri\u00e7\u00e3o","text":"<p>Esta fun\u00e7\u00e3o recebe um DataFrame, o caminho para salvar o arquivo e o nome do arquivo desejado. Antes de salvar, a fun\u00e7\u00e3o verifica se o diret\u00f3rio especificado existe, e se n\u00e3o existir, ele \u00e9 criado.</p>"},{"location":"pipeline/load/#funcao","title":"Fun\u00e7\u00e3o","text":"<p>Recebe um DataFrame e salva como Excel.</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>DataFrame</code> <p>DataFrame a ser salvo como Excel.</p> required <code>output_path</code> <code>str</code> <p>Caminho onde o arquivo ser\u00e1 salvo.</p> required <code>file_name</code> <code>str</code> <p>Nome do arquivo a ser salvo.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Mensagem de sucesso.</p> Source code in <code>app\\pipeline\\load.py</code> <pre><code>def load_excel(data_frame: pd.DataFrame, output_path: str, file_name: str) -&gt; str:\n    \"\"\"\n    Recebe um DataFrame e salva como Excel.\n\n    Args:\n        data_frame (pd.DataFrame): DataFrame a ser salvo como Excel.\n        output_path (str): Caminho onde o arquivo ser\u00e1 salvo.\n        file_name (str): Nome do arquivo a ser salvo.\n\n    Returns:\n        str: Mensagem de sucesso.\n    \"\"\"\n    # Garante que o diret\u00f3rio exista\n    if not os.path.exists(output_path):\n        os.makedirs(output_path)\n\n    # Caminho do arquivo usando os.path.join\n    file_path = os.path.join(output_path, f\"{file_name}.xlsx\")\n\n    # Salva o DataFrame como Excel\n    data_frame.to_excel(file_path, index=False)\n\n    return \"Arquivo salvo com sucesso\"\n</code></pre>"},{"location":"pipeline/transform/","title":"Transforma\u00e7\u00e3o de Dados","text":"<p>A fun\u00e7\u00e3o <code>concat_data_frames</code> \u00e9 respons\u00e1vel por transformar uma lista de DataFrames em um \u00fanico DataFrame consolidado.</p>"},{"location":"pipeline/transform/#funcao-de-transformacao-de-dados","title":"Fun\u00e7\u00e3o de Transforma\u00e7\u00e3o de Dados","text":""},{"location":"pipeline/transform/#descricao","title":"Descri\u00e7\u00e3o","text":"<p>Esta fun\u00e7\u00e3o combina v\u00e1rios DataFrames em um \u00fanico DataFrame, reorganizando os \u00edndices e garantindo a consist\u00eancia nos tipos de dados. \u00c9 uma etapa essencial para consolidar os dados antes do carregamento no destino.</p>"},{"location":"pipeline/transform/#funcao","title":"Fun\u00e7\u00e3o","text":"<p>Fun\u00e7\u00e3o para transformar uma lista de DataFrames em um \u00fanico DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data_frame_list</code> <code>List[DataFrame]</code> <p>Lista de DataFrames a serem concatenados.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame resultante da concatena\u00e7\u00e3o.</p> Source code in <code>app\\pipeline\\transform.py</code> <pre><code>def concat_data_frames(data_frame_list: List[pd.DataFrame]) -&gt; pd.DataFrame:\n    \"\"\"\n    Fun\u00e7\u00e3o para transformar uma lista de DataFrames em um \u00fanico DataFrame.\n\n    Args:\n        data_frame_list (List[pd.DataFrame]): Lista de DataFrames a serem concatenados.\n\n    Returns:\n        pd.DataFrame: DataFrame resultante da concatena\u00e7\u00e3o.\n    \"\"\"\n    if not data_frame_list:  # Verifica\u00e7\u00e3o para lista vazia\n        return pd.DataFrame()\n\n    result = pd.concat(data_frame_list, ignore_index=True)\n        # For\u00e7a as colunas a int64, ignorando NaN para evitar erros\n    for column in result.columns:\n        if pd.api.types.is_numeric_dtype(result[column]):\n            result[column] = result[column].fillna(0).astype(\"int64\")\n    return result\n</code></pre>"}]}